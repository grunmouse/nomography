{(../../ps-math/) stealfolder} /auto-diff-lib ifnotkey


%тип данных верхнего элемента стека, стек под ним не изменяется
/safetype {
	count
	0 eq
	{
		/nulltype
	}
	{
		dup type
	}
	ifelse
} def

% Рисует штрих, заданный полярными координатами
% dir - направление штриха в градусах
% length - длина штриха
%[ length, dir ]
/polar-line {
	gsave
		rotate
		0 rlineto
		stroke
	grestore
} def

%[length, dir]
/polar-to {
	exch
	1 index 
	% dir, length, dir
	rotate
	0 rlineto
	neg
	rotate
} def

%[f]
/scale-env {
	0 dict begin
		/fun exch def % Запоминаемая функция шкалы
		/diff {
			%[t]
			[ exch 1 ] % [ [t 1] ]
			auto-diff-lib begin
				fun
			end
		} def % [ [x(t) x'(t)] [y(t) y'(t)] ] - массив двух пар значений, покоординатно: функции и первой производной
		
		/curve-dir {
			%[x]
			dup
			[ exch diff]
			{
				dup type
				/arraytype eq
				{1 get} % если вошёл массив - значит это значение и производная
				{pop 0} % если не массив, значит это константа, её производная 0
				ifelse 
			} forall
			exch 
			atan
			exch pop
		} def % - положительное направление кривой в данной точке

		/step 1 def % Шаг черчения кривой
		/prepare {} def %функция подготовки значения прежде чем преобразовать его в строку
		/tostring {dup dup round eq {cvi} if 12 string cvs} def % Функция преобразования значения параметра в текст подписи
		/target { 0.5 0 0 0.5} def % Матрица расчёта точки прицеливания
		/space 2 def % Отступ подписи
		/level0 5 def % Длина штриха нулевого уровня вложенности делений
		/dlevel 1.5 def % Уменьшение длины штриха при увеличении уровня вложенности
		/a {} def % функция, вычисляющая курс входа по направлению штриха
		/dir {pop 0} def % функция, вычисляющая направление штриха по текущему аргументу
		
		%[level]
		/mark-len {
			dlevel mul neg
			level0 add
		} def
		
		% Установить новую матрицу точки прицеливания
		/settarget {
			4 array astore cvx 
			/target exch def
		} def
		
		% [x0, x1]
		/line {
			/fun load 3 1 roll
			f-line
		} def

		/curve {
			/fun load 3 1 roll
			step f-curve
		} def
		
		% Перейти в точку, заданную агрументом функции
		/movepos {
			dup /currentarg exch def % Сохраняем текущий аргумент
			fun moveto
		} def
		
		% Элементы оператора относительных координат точки прицеливания
		/left { 0 0 } def % абсцисса начала строки
		/first { 0 0.5 } def % абсцисса середины первого символа
		/center { 0.5 0 } def % абсцисса середины строки
		/last { 1 -0.5 } def % абсцисса середины последнего символа
		/right { 1 0 } def % абсцисса конца строки
		/top {0 1} def % ордината линии прописных
		/middle {0 0.5} def % средняя ордината
		/bottom {0 0} def % ордината базовой линии

		%Рисует надписанный штрих для указанного значения
		%[label, x] 
		%[x, label]
		%[x] - если строка опущена, то она будет создана их x
		/value {
			0 dict begin
				dup type
				dup
				dup 
				/integertype eq
				exch
				/realtype eq or
				{
					pop
					/x exch def
					safetype /stringtype eq
						{}
						{x prepare tostring}
						ifelse
					str-to-struct
					%[label]
				}
				{
					<<
						/stringtype {str-to-struct}
						/arraytype {str-to-struct}
						/dicttype {}
					>>
					exch get exec
					exch
					/x exch def
					%[label]
				} ifelse
				x movepos
				
				target 
				currentarg dir dup a exch
				space level0 point-detail
			end
		} def		
		

		% [label, dir2, lx, ly, x] - рисует надписанный штрих в виде выноски
		/out-label {
			gsave
			0 dict begin
				%x
				movepos
				
				level0 currentarg dir polar-to
				%lx ly
				lineto
				%pop pop
				%dir2
				/dir2 exch def
				%label
				
				dup type /stringtype eq
				{str-to-struct} if

				target
				dir2 a dir2 
				space 
				level0 
				%str, xw, xh, yw, yh, a, dir, space, length
				point-detail
			end
			grestore
		} def
		
		% [label, dir2, dlx, dly, x] - то же, но с относительным смещением
		/xout-label {
			0 dict begin
				/x exch def
				x fun
				2add
				%[label, dir2, lx, ly]
				x
				out-label
			end
		} def
		
		%[x, level]
		/mutemark {
			mark-len % x, len
			exch % len, x
			dup movepos
			dir	% len, dir
			polar-line
		} def
		
		% Двухуровневая группа немых штрихов на интервале 
		% (x1; x2) - интервал построения
		% c - цена малых делений
		% level - уровень штрихов делений, level-1 - уровень штрихов больших делений
		% m - цена больших делений
		% [ x1 x2 c level m ]
		/mutegroup2 {
			0 dict begin
				tofrac /m 2edef
				/level exch def
				tofrac /c 2edef
				tofrac /x2 2edef
				tofrac /x1 2edef
				
			gsave
				x1 c fraction-add
				c
				x2 c fraction-sub
				{
					%[nom, den]
					2dup div
					/x exch def
					%[nom, den]
					m
					fraction-has-div
					{
						%then
						x
						level 1 sub
						mutemark
					}
					{
						%else
						x
						level
						mutemark
					}
					ifelse
					
				} fraction-for
			
			grestore
			
			end
		} def
		
		% Группа немых штрихов на интервале 
		% (x1; x2) - интервал построения
		% c - цена делений
		% level - уровень штрихов делений
		% [ x1 x2 c level ]
		/mutegroup {
			0 dict begin
				/level exch def
				tofrac /c 2edef
				tofrac /x2 2edef
				tofrac /x1 2edef
				
				gsave
				x1 c fraction-add
				c
				x2 c fraction-sub
				{
					%[nom, den]
					div
					%[x]
					level
					mutemark
				} fraction-for
				grestore
			end
		} def
		
		%[x1, x1, step, mutestep, mutestep2]
		/linear-scale {
			0 dict begin
				/mutestep2 exch def
				/mutestep exch def
				tofrac /step 2edef
				tofrac /x2 2edef
				tofrac /x1 2edef
				mutestep2 null eq 
				{
					/mute {
						mutestep 2 mutegroup
					} def
				}
				{
					/mute {
						mutestep2 2 mutestep mutegroup2
					} def
				} ifelse
				
				/currentarg x1 2def
				x1 step x2
				{
					/nextarg 2edef
					[currentarg] [nextarg] mute
					nextarg div value
					/currentarg nextarg 2def
				} fraction-for
			end
		} def		
		
		%Если вместо функции пришёл словарь - значит нужно перенести из него всё в текущий словарь
		/fun load type
		/dicttype eq
		{
			fun
			currentdict
			copy
			pop
		}
		if

		currentdict
	end
} def