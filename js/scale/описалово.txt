Я разрабатываю алгоритм подбора разметки функциональной шкалы.
Шкала - это множество точек, которым сопоставлены числовые значения откладываемой величины. Кривая на плоскости, соответствующая этому множеству называется носителем шкалы. Некоторые точки шкалы обозначены штрихами. Штрихи, около которых есть значения, называются надписанными, остальные - немыми. Цена деления немых штрихов между парой надписанных должна быть постоянной.
На входе: пределы откладываемой величины, объект levels, представляющий множество хороших цен деления, функция distance, вычисляющая для двух значений откладываемой величины геометрическое расстояние между соответствующими точками, а также условия mutedist {min max} - желательный разброс длин делений немых штрихов, и labeldist {min, max} - желательный разброс расстояний между соседними надписанными штрихами.

Мой подход к решению:
Рассматриваем шкалу как одномерную сущность. Учёт её реального положения в пространстве заложен в функцию distance и инкапсулирован в ней.

1. Для данного отрезка шкалы (между пределами откладываемой величины) выбрать из множества levels все цены делений, которые дают внутри данного отрезка шкалы хотя бы одно деление, удовлетворяющее условию mutedist.

1.1. Внутри процедуры трассировки нужно улучшить алгоритм для случая, когда в начале шкалы требуется шаг много больший, чем в конце. Имеет смысл искать бинарным поиском наибольший допустимый шаг.


2. Для каждой выбранной цены деления найти на данном отрезке шкалы один или несколько подотрезков, на протяжение которых все деления удовлетворяют mutedist.

3. Найти пересечения этих подотрезков друг с другом. 
3.1 Если на шкале остались участки, не покрытые ни одним отрезком, выработать рекомендации по смягчению условия mutedist.
3.2. Если есть отрезки, которые полностью входят внутрь большего отрезка, разрешить ситуацию одним из способов: а. удалить меньший; б. разбить больший на два, так чтобы место разделения находилось внутри меньшего.
3.2.1. На отрезке A нужно найти все точки, которые подходят для цены деления и A, и B. Если расстояние между крайними такими точками меньше labeldist.min - A удаляется.
3.2.2. Если A прошёл проверку по длине, нужно разбить B на B1 и B2 так, чтобы внутри A среди найденных выше точек нашлись хорошие точки, в качестве границ B1/A и A/B1. И проверить, что новые сегменты B1 и B2 не становятся слишком короткими. Если такие точки не найдутся, нужно либо удалить A и восстановить B, либо смягчить требование labeldist.
3.3. Если отрезок A полностью покрыт сразу несколькими другими отрезками, что делать. Нужна какая-то сведения этой задачи к подзадачам.


4. На пересечении каждой пары отрезков найти точки, удовлетворяющие цене деления и первого и второго подотрезка. Из этих точек выбрать лучшую точку и назначить её границей между отрезками.
4.1. Рассмотреть вариант введения промежуточной цены деления и соответствующего ей нового отрезка внутри области пересечения.

5. Границы отрезков считать надписанными штрихами и проверить расстояния между ними на условие labeldist.

6. Потом внутри слишком длинны отрезков нужно найти дополнительные точки для надписанных штрихов, чтобы выполнить условие labeldist.

7. Слишком короткие отрезки как-то обработать. 
7.1. Предложить уменьшение labeldist.min
7.2. Удалить слишком короткий отрезок и расширить соседние отрезки за его счёт, это может привести к нарушению mutedist, тогда предложить смягчение mutedist (п.3.1)
7.2.1. Если соседние отрезки имеют одинаковую цену деления, нужно объединить их в один и предложить соответствующее смягчение mutedist. Если требуется неприемлемо сильное смягчение - отказаться от удаления отрезка и предложить уменьшение labeldist.min. Либо руководствоваться общей метрикой штрафов, учитывающих mutedist и labeldist (будет разработана).