Я разрабатываю алгоритм подбора разметки функциональной шкалы.
Шкала - это множество точек, которым сопоставлены числовые значения откладываемой величины. Кривая на плоскости, соответствующая этому множеству называется носителем шкалы. Некоторые точки шкалы обозначены штрихами. Штрихи, около которых есть значения, называются надписанными, остальные - немыми. Цена деления немых штрихов между парой надписанных должна быть постоянной.
На входе: пределы откладываемой величины, объект levels, представляющий множество хороших цен деления, функция distance, вычисляющая для двух значений откладываемой величины геометрическое расстояние между соответствующими точками, а также условия mutedist {min max} - желательный разброс длин делений немых штрихов, и labeldist {min, max} - желательный разброс расстояний между соседними надписанными штрихами.

Нужно покрыть весю шкалу последовательностью непересекающихся отрезков, каждый со своей ценой деления. При этом:
- Внутри каждого отрезка все деления должны удовлетворять mutedist.
- Расстояния между надписями (границами отрезков) должны удовлетворять labeldist.

Разработана общая метрика штрафов, которая вычисляет штраф за выход какой-то величины за положенные ей границы, и операция "сложения" штрафов, которая комутативна, ассоциативна, субаддитивна, и нестрого монотонна по первому аргументу при постоянном втором (или наоборот - т.к. она коммутативна).

Мой подход к решению:
Рассматриваем шкалу как одномерную сущность. Учёт её реального положения в пространстве заложен в функцию distance и инкапсулирован в ней.

1. Процедура трассировки движется от одного конца отрезка к другому и решает две задачи:
а) Для данного отрезка шкалы (между пределами откладываемой величины) выбрать из множества levels все цены делений, которые дают внутри данного отрезка шкалы хотя бы одно деление, удовлетворяющее условию mutedist.
б). Для каждой выбранной цены деления найти на данном отрезке шкалы один или несколько подотрезков, на протяжение которых все деления удовлетворяют mutedist.
1.1. Принцип действия: начав с длины шага, наименьшей из подходящих для данного конца шкалы, делать шаги этой величины, пока длина очередного шага не нарушит mutedist; тогда изменить величину шага на следующую большую или меньшую, и трассировать отрезок этим шагом от точки завершения трассировки предыдущим шагом сначала в обратную сторону, для установления границ нового подотрезка, а потом в прямую - для продолжения трассировки по тому же алгориму.
1.2. Целесообразно сделать два прохода трассировки: от начала к концу и от конца к началу. И объединить полученные множества отрезков (с удалением дубликатов и объединением пересекающихся отрезков, если цена деления общая).

2. Найти пересечения этих подотрезков друг с другом. 
2.1 Если на шкале остались участки, не покрытые ни одним отрезком, выработать рекомендации по смягчению условия mutedist.
2.2. Если есть отрезки, которые полностью входят внутрь большего отрезка, разрешить ситуацию одним из способов: а. удалить меньший; б. разбить больший на два, так чтобы место разделения находилось внутри меньшего.
2.2.1. На отрезке A нужно найти все точки, которые подходят для цены деления и A, и B. Если расстояние между крайними такими точками меньше labeldist.min - A удаляется.
2.2.2. Если A прошёл проверку по длине, нужно разбить B на B1 и B2 по двум из найденных выше точек, так, чтобы на следующем этапе алгоритма обеспечивалась возможность на выбрать на пересечении B1/A и A/B1 границы отрезков с допустимой длиной A.
2.2.3. Проверить, что новые сегменты B1 и B2 не становятся слишком короткими, но ненулевыми. Если B1 или B2 может быть нулевым - не его. Если не может, но при этом слишком короткий - как-то разрешить.
2.3. Если отрезок A полностью покрыт сразу несколькими другими отрезками, что делать. Нужны какие-то правила сведения этой задачи к подзадачам. Возможно, какой-то алгоритм на графах.


3. На пересечении каждой пары отрезков найти точки, удовлетворяющие цене деления и первого и второго подотрезка. Из этих точек выбрать лучшую точку и назначить её границей между отрезками. (Нужен алгоритм выбора лучшей точки. Вероятно по метрике штрафов)
3.1. Рассмотреть вариант введения промежуточной цены деления (если она разрешена объектом levels) и соответствующего ей нового отрезка внутри области пересечения.

4. Границы отрезков считать надписанными штрихами и проверить расстояния между ними на условие labeldist.

5. Потом внутри слишком длинных отрезков нужно найти дополнительные точки для надписанных штрихов, чтобы выполнить условие labeldist.

6. Слишком короткие отрезки как-то обработать. 
6.1. Предложить уменьшение labeldist.min
6.2. Удалить слишком короткий отрезок и расширить соседние отрезки за его счёт, это может привести к нарушению mutedist, тогда предложить смягчение mutedist (п.3.1)
6.2.1. Если соседние отрезки имеют одинаковую цену деления, нужно объединить их в один и предложить соответствующее смягчение mutedist. Если требуется неприемлемо сильное смягчение - отказаться от удаления отрезка и предложить уменьшение labeldist.min. Руководствоваться общей метрикой штрафов.